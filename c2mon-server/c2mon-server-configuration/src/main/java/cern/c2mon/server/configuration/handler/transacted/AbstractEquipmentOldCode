  /**
   * Ensures that the Alive-, Status- and CommFault Tags have appropriately the equipment id set.
   *
   * @param equipment The equipment to which the control tags are assigned
   */
  private List<ProcessChange> updateControlTagInformation(final ConfigurationElement element, final Equipment equipment) {

    List<ProcessChange> changes = new ArrayList<ProcessChange>(3);
    Long processId = equipment.getProcessId();
    Long equipmentId = equipment.getId();

    if (equipment.getAliveTagId() != null) {
      ControlTag aliveTagCopy = controlCache.getCopy(equipment.getAliveTagId());
      if (aliveTagCopy != null) {
        setEquipmentId((ControlTagCacheObject) aliveTagCopy, equipmentId, processId);

        if (aliveTagCopy.getAddress() != null) {
          IChange toAdd = new DataTagAdd(element.getSequenceId(), equipmentId, controlTagFacade.generateSourceDataTag(aliveTagCopy));
          ConfigurationElementReport report = new ConfigurationElementReport(Action.CREATE, Entity.CONTROLTAG, aliveTagCopy.getId());
          ProcessChange change = new ProcessChange(processId, toAdd);
          change.setNestedSubReport(report);
          changes.add(change);
        }
      } else {
        throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
          String.format("No Alive tag (%s) found for equipment #%d (%s).", equipment.getAliveTagId(), equipment.getId(), equipment.getName()));
      }
    }

    ControlTag commFaultTagCopy = controlCache.getCopy(equipment.getCommFaultTagId());
    if (commFaultTagCopy != null) {
      setEquipmentId((ControlTagCacheObject) commFaultTagCopy, equipmentId, processId);
    } else {
      throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
        String.format("No CommFault tag (%s) found for equipment #%d (%s).", equipment.getCommFaultTagId(), equipment.getId(), equipment.getName()));
    }

    ControlTag statusTagCopy = controlCache.getCopy(equipment.getStateTagId());
    if (statusTagCopy != null) {
      setEquipmentId((ControlTagCacheObject) statusTagCopy, equipmentId, processId);
    } else {
      throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
        String.format("No Status tag (%s) found for equipment #%d (%s).", equipment.getStateTagId(), equipment.getId(), equipment.getName()));
    }

    return changes;
  }

  private void setEquipmentId(ControlTagCacheObject copy, Long equipmentId, Long processId) {
    String logMsg = String.format("Adding equipment id #%s to control tag #%s", equipmentId, copy.getId());
    log.trace(logMsg);
    copy.setEquipmentId(equipmentId);
    copy.setProcessId(processId);
    controlCache.putQuiet(copy);
  }


 /**
   * Ensures that the Alive-, Status- and CommFault Tags have appropriately the sub-equipment id set.
   * @param subEquipment The sub-equipment to which the control tags are assigned
   */
  private List<ProcessChange> updateControlTagInformation(final ConfigurationElement element, final SubEquipment subEquipment) {

      List<ProcessChange> changes = new ArrayList<ProcessChange>(3);
      final Long processId = subEquipmentFacade.getProcessIdForAbstractEquipment(subEquipment.getId());

      ControlTag aliveTagCopy = controlCache.getCopy(subEquipment.getAliveTagId());
      if (aliveTagCopy != null) {
        setSubEquipmentId((ControlTagCacheObject) aliveTagCopy, subEquipment.getId(), processId);

        if (aliveTagCopy.getAddress() != null) {
          // Inform Process about newly added alive tag
          IChange toAdd = new DataTagAdd(element.getSequenceId(), subEquipment.getId(), controlTagFacade.generateSourceDataTag(aliveTagCopy));
          ConfigurationElementReport report = new ConfigurationElementReport(Action.CREATE, Entity.CONTROLTAG, aliveTagCopy.getId());
          ProcessChange change = new ProcessChange(processId, toAdd);
          change.setNestedSubReport(report);
          changes.add(change);
        }
        else {
          throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
              String.format("Alive tag #%d (%s) for sub-equipment #%d (%s) must by definition have a hardware address defined.", aliveTagCopy.getId(), aliveTagCopy.getName(), subEquipment.getId(), subEquipment.getName()));
        }

      } else {
        throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
            String.format("No Alive tag (%s) found for sub-equipment #%d (%s).", subEquipment.getAliveTagId(), subEquipment.getId(), subEquipment.getName()));
      }


      ControlTag commFaultTagCopy = controlCache.getCopy(subEquipment.getCommFaultTagId());
      if (commFaultTagCopy != null) {
        setSubEquipmentId((ControlTagCacheObject) commFaultTagCopy, subEquipment.getId(), processId);
      } else {
        throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
            String.format("No CommFault tag (%s) found for sub-equipment #%d (%s).", subEquipment.getCommFaultTagId(), subEquipment.getId(), subEquipment.getName()));
      }


      ControlTag statusTagCopy = controlCache.getCopy(subEquipment.getStateTagId());
      if (statusTagCopy != null) {
        setSubEquipmentId((ControlTagCacheObject) statusTagCopy, subEquipment.getId(), processId);
      } else {
        throw new ConfigurationException(ConfigurationException.INVALID_PARAMETER_VALUE,
            String.format("No Status tag (%s) found for sub-equipment #%d (%s).", subEquipment.getStateTagId(), subEquipment.getId(), subEquipment.getName()));
      }

      return changes;
  }

  private void setSubEquipmentId(ControlTagCacheObject copy, Long subEquipmentId, Long processId) {
    String logMsg = String.format("Adding sub-equipment id #%s to control tag #%s", subEquipmentId, copy.getId());
    log.trace(logMsg);
    copy.setSubEquipmentId(subEquipmentId);
    copy.setProcessId(processId);
    controlCache.putQuiet(copy);
  }

  /**
   * Can be called directly for both Equipment and SubEquipment configuration
   * updates.
   *
   * <p>
   * Updates made to Equipments are done programmatically both in cache and DB,
   * to avoid reloading the Equipment from the DB at runtime, which can be
   * time-consuming if many tags are declared.
   *
   * <p>
   * Should be called within the AbstractEquipment write lock.
   *
   * <p>
   * Should not throw the {@link IllegalAccessException} (only Tags can).
   *
   * @param equipmentId of the (Sub)Equipment
   * @param properties  containing the changed fields
   * @return ProcessChange used only for Equipment reconfiguration (not
   * SubEquipment)
   * @throws IllegalAccessException not thrown for Equipment
   */
  protected List<ProcessChange> updateAbstractEquipment(final T abstractEquipment, final Properties properties) throws IllegalAccessException {
    EquipmentConfigurationUpdate equipmentUpdate;
    equipmentUpdate = (EquipmentConfigurationUpdate) commonEquipmentFacade.updateConfig(abstractEquipment, properties);
    configurableDAO.updateConfig(abstractEquipment);

    // create change event for DAQ layer
    Long processId = commonEquipmentFacade.getProcessIdForAbstractEquipment(abstractEquipment.getId());
    ArrayList<ProcessChange> processChanges = new ArrayList<>();
    processChanges.add(new ProcessChange(commonEquipmentFacade.getProcessIdForAbstractEquipment(abstractEquipment.getId()), equipmentUpdate));
    // if alive tags associated to equipment are changed and have an address,
    // inform DAQ also (use same changeId so these become sub-reports of the
    // correct report)
    if (equipmentUpdate.getAliveTagId() != null) {
      ProcessChange processChange = controlTagConfigHandler.getCreateEvent(equipmentUpdate.getChangeId(), abstractEquipment.getAliveTagId(), abstractEquipment
        .getId(), processId);
      // null if this alive does not have an Address -> is not in list of
      // DataTags on DAQ
      if (processChange != null) {
        ConfigurationElementReport subReport = new ConfigurationElementReport(Action.CREATE, Entity.CONTROLTAG, equipmentUpdate.getAliveTagId());
        processChange.setNestedSubReport(subReport);
        processChanges.add(processChange);
      }
    }
    return processChanges;
  }


  /**
   * Removes the control tags for this equipment. Notice that if this fails, the
   * equipment object will still be removed: this is to prevent the situation of
   * not being able to remove the equipment because of the control tags (say if another
   * equipment is also using them by mistake) and not being able to remove the
   * control tags because of the equipment.
   *
   * <p>Notice that in case of failure, only part of the control tags could remain; they
   * are removed in the following order: Alive tag, CommFaultTag, State tag.
   *
   * @param abstractEquipment the AbstracEquipment to remove
   * @param equipmentReport for adding the sub-reports to
   */
  protected List<ProcessChange> removeEquipmentControlTags(final AbstractEquipment abstractEquipment, final ConfigurationElementReport equipmentReport) {
    List<ProcessChange> changes = new ArrayList<>();

    log.debug("Removing (Sub-)Equipment control tags.");
    Long aliveTagId = abstractEquipment.getAliveTagId();

    if (aliveTagId != null) {
      ConfigurationElementReport tagReport = new ConfigurationElementReport(Action.REMOVE, Entity.CONTROLTAG, aliveTagId);

      ProcessChange change = controlTagConfigHandler.remove(aliveTagId, tagReport);
      if (change.processActionRequired()) {
        change.setNestedSubReport(tagReport);
        changes.add(change);
      }
      else {
        equipmentReport.addSubReport(tagReport);
      }
    }

    Long commTagId = abstractEquipment.getCommFaultTagId();
    if (commTagId != null) {
      ConfigurationElementReport tagReport = new ConfigurationElementReport(Action.REMOVE, Entity.CONTROLTAG, commTagId);

      ProcessChange change = controlTagConfigHandler.remove(commTagId, tagReport);
      if (change.processActionRequired()) {
        change.setNestedSubReport(tagReport);
        changes.add(change);
      }
      else {
        equipmentReport.addSubReport(tagReport);
      }
    }

    Long stateTagId = abstractEquipment.getStateTagId();
    ConfigurationElementReport tagReport = new ConfigurationElementReport(Action.REMOVE, Entity.CONTROLTAG, stateTagId);

    ProcessChange change = controlTagConfigHandler.remove(stateTagId, tagReport);
    if (change.processActionRequired()) {
      change.setNestedSubReport(tagReport);
      changes.add(change);
    }
    else {
      equipmentReport.addSubReport(tagReport);
    }
    return changes;
  }

  /**
   * Common part of (Sub-)Equipment update method. Mainly deals
   * with rollback of other cache changes in case of failure.
   *
   * @param abstractEquipmentId id of (sub)equipment
   * @param elementProperties properties with update details
   * @return changes to be sent to the DAQ layer
   * @throws IllegalAccessException if thrown when updating fields
   */
  protected List<ProcessChange> commonUpdate(Long abstractEquipmentId, Properties elementProperties) throws IllegalAccessException {
    log.debug("Updating (sub-)equipment {}", abstractEquipmentId);
    // TODO or not todo: warning: can still update commfault, alive and state
    // tag id to non-existent tags (id is NOT checked and exceptions will be
    // thrown!)

    // do not allow id changes! (they would not be applied in any case)
    if (elementProperties.containsKey("id")) {
      log.warn("Attempting to change the equipment/subequipment id - this is not currently supported!");
      elementProperties.remove("id");
    }
    boolean aliveConfigure = false;
    if (elementProperties.containsKey("aliveInterval") || elementProperties.containsKey("aliveTagId")) {
      aliveConfigure = true;
    }
    boolean commFaultConfigure = false;
    if (elementProperties.containsKey("commFaultTagId")) {
      commFaultConfigure = true;
    }
    abstractEquipmentCache.acquireWriteLockOnKey(abstractEquipmentId);
    try {
      T abstractEquipmentCopy = abstractEquipmentCache.getCopy(abstractEquipmentId);
      try {
        Long oldAliveId = abstractEquipmentCopy.getAliveTagId();
        Long oldCommFaultId = abstractEquipmentCopy.getCommFaultTagId();
        List<ProcessChange> processChanges = abstractEquipmentConfigTransacted.update(abstractEquipmentCopy, elementProperties);

        // commit local changes back to the cache
        abstractEquipmentCache.putQuiet(abstractEquipmentCopy);
        abstractEquipmentCache.releaseWriteLockOnKey(abstractEquipmentId);

        if (aliveConfigure) {
          if (oldAliveId != null)
            commonEquipmentFacade.removeAliveDirectly(oldAliveId);
          if (abstractEquipmentCopy.getAliveTagId() != null)
            commonEquipmentFacade.loadAndStartAliveTag(abstractEquipmentCopy.getId());
        }
        if (commFaultConfigure && abstractEquipmentCopy.getCommFaultTagId() != null) {
          if (oldCommFaultId != null)
            commFaultTagCache.remove(oldCommFaultId);
          if (abstractEquipmentCopy.getCommFaultTagId() != null)
            commFaultTagCache.loadFromDb(abstractEquipmentCopy.getCommFaultTagId());
        }

        return processChanges;
      } catch (RuntimeException ex) {
        log.error("Exception caught while updating (sub-)equipment - rolling back changes", ex);
        //reload all potentially updated cache elements now DB changes are rolled back
        if (abstractEquipmentCache.isWriteLockedByCurrentThread(abstractEquipmentId)) {
          abstractEquipmentCache.releaseWriteLockOnKey(abstractEquipmentId);
        }
        commFaultTagCache.remove(abstractEquipmentCopy.getCommFaultTagId());
        aliveTimerCache.remove(abstractEquipmentCopy.getAliveTagId());
        abstractEquipmentCache.remove(abstractEquipmentId);
        T oldAbstractEquipment = abstractEquipmentCache.get(abstractEquipmentId);
        commFaultTagCache.loadFromDb(oldAbstractEquipment.getCommFaultTagId());
        commonEquipmentFacade.loadAndStartAliveTag(abstractEquipmentId); //reloads alive from DB
        throw ex;
      }
    }
  }
